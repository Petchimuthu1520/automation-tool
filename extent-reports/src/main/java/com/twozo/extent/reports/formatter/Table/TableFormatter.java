package com.twozo.extent.reports.formatter.Table;

import com.twozo.extent.reports.formatter.Formatter;
import lombok.Builder;

import java.lang.reflect.Array;
import java.util.Arrays;
import java.util.Collection;
import java.util.Map;

/**
 * Generating HTML markup for tables. It implements {@link Formatter},
 * which defines a method for retrieving the markup generated by this class.
 * <p>
 * Provides flexibility in generating tables from different sources of data, including
 * multidimensional arrays, collections, maps, and single objects.
 *
 * @version 1.0
 * @Author Navin Jones
 * @see Formatter
 */

@Builder
public final class TableFormatter implements Formatter {

    private final String[][] tableData;
    private final Object sourceObject;
    private final String[] headerRow;
    private String tableAttributes;

    /**
     * Generates the HTML markup for the table based on the provided data and attributes.
     *
     * @return The HTML markup representing the table.
     */
    @Override
    public String getMarkup() {
        if (headerRow != null && headerRow.length > 0) {
            tableAttributes = String.join(" ", headerRow);
        }

        if (tableData != null) {
            return generateTableFromData();
        }

        try {
            return generateTableFromObject();
        } catch (IllegalArgumentException | IllegalAccessException e) {
            e.printStackTrace();
        }

        return "";
    }

    /**
     * Generates a table from the provided data.
     *
     * @return The HTML markup representing the table.
     */
    private String generateTableFromData() {
        final StringBuilder htmlBuilder = new StringBuilder();

        htmlBuilder.append("<table border='1").append(tableAttributes).append("'>");

        for (final String[] row : tableData) {
            htmlBuilder.append("<tr>");

            for (final String cell : row) {
                htmlBuilder.append("<td>").append(cell).append("</td>");
            }
            htmlBuilder.append("</tr>");
        }
        htmlBuilder.append("</table>");

        return htmlBuilder.toString();
    }

    /**
     * Generates a table from the source object.
     *
     * @return The HTML markup representing the table.
     * @throws IllegalArgumentException If the source object is invalid.
     * @throws IllegalAccessException   If access to the source object is illegal.
     */
    private String generateTableFromObject() throws IllegalArgumentException, IllegalAccessException {
        if (sourceObject == null) {
            return "";
        }

        final StringBuilder htmlBuilder = new StringBuilder();
        final StringBuilder contentBuilder = new StringBuilder();

        htmlBuilder.append("<table border='1' ").append(tableAttributes).append(">");
        htmlBuilder.append("<tbody>");

        if (sourceObject instanceof Map) {
            appendMapItems((Map<?, ?>) sourceObject, contentBuilder);
        } else if (sourceObject instanceof Collection || sourceObject.getClass().isArray()) {
            appendCollectionItems(sourceObject, contentBuilder);
        } else {
            appendSingleItem(sourceObject, contentBuilder);
        }

        htmlBuilder.append(contentBuilder);
        htmlBuilder.append("</tbody>");
        htmlBuilder.append("</table>");

        return htmlBuilder.toString();
    }

    /**
     * Appends key-value pairs from a map to the table.
     *
     * @param map            The map containing the data.
     * @param contentBuilder The StringBuilder to append the content to.
     */
    private void appendMapItems(final Map<?, ?> map, final StringBuilder contentBuilder) {
        map.forEach((key, value) -> contentBuilder.append("<tr><td>").append(key).append("</td><td>").append(value).append("</td></tr>"));
    }

    /**
     * Appends items from a collection to the table.
     *
     * @param collection  The collection containing the data.
     * @param htmlBuilder The StringBuilder to append the HTML markup to.
     */
    private void appendCollectionItems(Object collection, StringBuilder htmlBuilder) {
        Collection<?> coll = (collection instanceof Collection) ? (Collection<?>) collection : Arrays.asList(toArray(collection));
        coll.forEach(item -> {
            if (item instanceof String) {
                appendStringRow((String) item, htmlBuilder);
            } else {
                htmlBuilder.append("<tr><td>").append(item).append("</td></tr>");
            }
        });
    }

    /**
     * Appends a single item to the table.
     *
     * @param item        The item to be appended.
     * @param htmlBuilder The StringBuilder to append the HTML markup to.
     */
    private void appendSingleItem(Object item, StringBuilder htmlBuilder) {
        htmlBuilder.append("<tr><td>").append(item).append("</td></tr>");
    }

    /**
     * Appends a string row split by commas to the table.
     *
     * @param row         The string row to be split and appended.
     * @param htmlBuilder The StringBuilder to append the HTML markup to.
     */
    private void appendStringRow(String row, StringBuilder htmlBuilder) {
        String[] columns = row.split(",\\s*");
        htmlBuilder.append("<tr>");
        for (String column : columns) {
            htmlBuilder.append("<td>").append(column).append("</td>");
        }
        htmlBuilder.append("</tr>");
    }

    /**
     * Converts an array to an Object array.
     *
     * @param array The array to be converted.
     * @return The converted Object array.
     */
    private Object[] toArray(Object array) {
        int length = Array.getLength(array);
        Object[] result = new Object[length];
        for (int i = 0; i < length; i++) {
            result[i] = Array.get(array, i);
        }
        return result;
    }
}